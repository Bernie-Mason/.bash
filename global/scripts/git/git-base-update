#!/bin/bash
#
# A git helper script to bring the current working branch up to date with another specified branch by rebasing.
# If no branch is specified, it defaults to the main or master branch. If both exist, it will prompt the user to choose one.
# The script will also check for uncommitted changes and will not proceed if any are found.
# The script will also check if the current branch is the default branch and will not proceed if it is.

VERBOSE=false
REMOTE=""
TARGET_BRANCH=""
CURRENT_BRANCH=""
UPSTREAM=""
CHANGES_STASHED=false
SYNC_UPSTREAM=false

source $logging_utils_path
source $git_utils_path

function help() {
    log-info "Usage: $0 [-u] [-v] [-h] [branch]"
    log-info "  -u|-upstream: Sync the current branch with its upstream branch"
    log-info "  -v|-verbose: Enable verbose mode"
    log-info "  -h|-help: show this help message"
    log-info "  branch: The branch to rebase onto (default if none specific: main or master)"
    log-info "  If both main and master branches exist, you will be prompted to choose one."
    die 0 ""
}

# Handle optional arguments. All arguments are optional.
# switch through the arguments
while getopts ":verbose:help:upstream" opt; do
    case $opt in
        v|verbose) VERBOSE=true ;;
        u|upstream) SYNC_UPSTREAM=true; ;;
        h|help) help ;;
        \?) help ;;
    esac
done
shift $((OPTIND - 1))
# Check if the user has provided a branch name
if [ $# -gt 0 ]; then
    TARGET_BRANCH=$1
else
    TARGET_BRANCH=""
fi

function die() {
    local exit_code=$1
    shift
    echo -e "${RED}$@${NC}" >&2
    exit $exit_code
}

function validate-git-repo(){
    $VERBOSE && title "Validating git repository..."
    # Check if we are in a git repository
    if ! git rev-parse --is-inside-work-tree &>/dev/null; then
        die 1 "Not in a git repository. Exiting."
    fi

    # Check if there are any uncommitted changes
    if ! git diff-index --quiet HEAD --; then
        log-warn "There are uncommitted changes."
        # Offer to stash changes
        read -p "Do you want to stash them? (y/n): " choice
        if [[ "$choice" == "y" ]]; then
            git stash || die 1 "Failed to stash changes."
            CHANGES_STASHED=true
            log-info "Changes stashed. You can apply them later using 'git stash apply'."
        else
            die 1 "Please commit or stash your changes before running this script."
        fi
    fi

    $VERBOSE && log-info "Git repository validated."
}

# If not target branch argument provided then we discover the default branch
function set-target-branch-as-default() {
    $VERBOSE && title "Setting target branch as default..."
    TARGET_BRANCH=$(git branch --list "main" "master" | head -n 1 | sed 's/^[* ] //')
    if [ -z "$TARGET_BRANCH" ]; then
        die 1 "Error: No branches found in the repository."
    fi

    # Check if both branches exists and give an option to the user on which one to use
    if git show-ref --verify --quiet refs/heads/main && git show-ref --verify --quiet refs/heads/master; then
        log-info "Both main and master branches exist. Which one do you want to use?"
        select branch in "main" "master"; do
            case $branch in
                main ) TARGET_BRANCH="main"; break;;
                master ) TARGET_BRANCH="master"; break;;
                * ) log-warn "Invalid option. Please try again.";;
            esac
        done
    fi
    $VERBOSE && log-info "Using target branch: $TARGET_BRANCH"
}

function rebase-onto-target() {
    $VERBOSE && title "Rebasing the current branch $CURRENT_BRANCH onto $TARGET_BRANCH..."

    local rebase_target=""
    if [[ ! -z "$REMOTE" ]]; then
        # Fetch the latest changes from the remote to ensure we are syncing our branch with the latest changes of the target branch
        $VERBOSE && log-info "Fetching the latest changes from $REMOTE..."
        git fetch -q $REMOTE $TARGET_BRANCH || die 1 "Failed to fetch from $REMOTE."
        rebase_target="$REMOTE/$TARGET_BRANCH"
    else
        $VERBOSE && log-warn "No remote found. Rebasing on to local branch only."
        rebase_target="$TARGET_BRANCH"
    fi

    # Check if the current branch is based on the tip of the mainline branch
    $VERBOSE && log-info "Checking if the current branch is up-to-date with $rebase_target..."
    local target_tip=$(git rev-parse $rebase_target)
    local branch_base=$(git merge-base @ $rebase_target)

    if [[ "$branch_base" != "$target_tip" ]]; then
        log-info "The working branch $CURRENT_BRANCH is not based on the tip of $rebase_target."
        read -p "Do you want to rebase $CURRENT_BRANCH onto $rebase_target? (y/n): " choice
        if [[ "$choice" == "y" ]]; then
            git rebase -q $rebase_target || die 1 "Rebase onto $rebase_target failed. Resolve conflicts and try again."
            log-success "Successfully rebased $CURRENT_BRANCH onto $rebase_target."
        else
            die 0 "Skipping rebase onto $rebase_target."
        fi
    else            
        $VERBOSE && log-info "No rebase action required as the working branch $CURRENT_BRANCH is already based on the tip of $REMOTE/$TARGET_BRANCH."
    fi
}

function set-git-parameters()
{
    $VERBOSE && title "Setting current branch, remote and finding upstream..."
    
    CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
    if [ "$CURRENT_BRANCH" == "$TARGET_BRANCH" ]; then
        die 1 "No need to update the current branch ($TARGET_BRANCH) onto itself."
    fi

    if [[ $(git remote | wc -l) -gt 1 ]]; then
        log-info "Multiple remotes found. Please choose one:"
        select remote in $(git remote); do
            REMOTE=$remote
            break
        done
    else
        REMOTE=$(git remote)
    fi

    if [[ -z "$REMOTE" ]]; then
        $SYNC_UPSTREAM = false
        $VERBOSE && log-warn "No remote found. Skipping upstream branch setup."
    fi

    $SYNC_UPSTREAM && UPSTREAM=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)

    $VERBOSE && log-info "Using remote: $REMOTE"
}

function ensure-upstream-branch() {
    $VERBOSE && title "Ensuring upstream branch is set..."
    # Check if the upstream branch is set
    if [[ -z "$UPSTREAM" ]]; then
        $VERBOSE && log-warn "No upstream branch set for $CURRENT_BRANCH."
        read -p "Do you want to you want to push your current branch? (y/n): " choice
        if [[ "$choice" == "y" ]]; then
            git push || die 1 "Failed to set upstream branch."
            UPSTREAM=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)
            return 0
        else
            $VERBOSE && log-warn "Skipping upstream branch setup."
            return 0
        fi
    fi
}

validate-git-repo
[ -z "$TARGET_BRANCH" ] && set-target-branch-as-default
set-git-parameters

# Optional upstream work. We expect that the user is about to rebase the current branch onto the target branch
# which means that the upstream branch will diverge from the current branch. As such being ahead or diverged from the 
# upstream currently does not matter. We will only check if the upstream branch is behind the current branch
# and will offer to pull the changes in this case.
if [[ ! -z "$UPSTREAM" ]]; then
    status=$(get-upstream-status)
    case "$status" in
        "no-upstream") ;;
        "up-to-date") $VERBOSE && log-info "The working branch $CURRENT_BRANCH is up-to-date with $UPSTREAM." ;;
        "behind")
            log-warn "The working branch $CURRENT_BRANCH is behind $UPSTREAM. Before you rebase, you may want to pull the latest changes."
            read -p "Do you want to pull the latest changes from $UPSTREAM? (y/n): " choice
            if [[ "$choice" == "y" ]]; then
                git pull || die 1 "Failed to pull changes from $UPSTREAM."
            else
                log-warn "Skipping pull operation."
            fi
            ;;
        "ahead") $VERBOSE && log-warn "The working branch $CURRENT_BRANCH is ahead of $UPSTREAM." ;;
        "diverged") $VERBOSE && log-warn "The working branch $CURRENT_BRANCH has diverged from $UPSTREAM.";;
        *) $VERBOSE && log-warn "Unknown upstream status: $status" ;;
    esac
fi

rebase-onto-target

if [ $SYNC_UPSTREAM = true ]; then
    if [[ -z "$UPSTREAM" ]]; then
        ensure-upstream-branch
    else
        # If any rebase occured then the upstream branch has diverged from the current branch
        # and we need to force push the changes to the remote branch. However, if no rebase occured
        # then we need to check the status of the upstream branch and offer to pull or push changes
        status=$(get-upstream-status)
        switch "$status" in
            "no-upstream") ;;
            "up-to-date") ;;
            "behind")
                $VERBOSE && log-warn "The working branch $CURRENT_BRANCH is behind $UPSTREAM."
                read -p "Do you want to pull the latest changes from $UPSTREAM? (y/n): " choice
                if [[ "$choice" == "y" ]]; then
                    git pull || die 1 "Failed to pull changes from $UPSTREAM."
                else
                    $VERBOSE && log-warn "Skipping pull operation."
                fi
                ;;
            "ahead")
                $VERBOSE && log-warn "The working branch $CURRENT_BRANCH is ahead of $UPSTREAM."
                read -p "Do you want to push your changes to $UPSTREAM? (y/n): " choice
                if [[ "$choice" == "y" ]]; then
                    git push || die 1 "Failed to push changes to $UPSTREAM."
                else
                    $VERBOSE && log-warn "Skipping push operation."
                fi
                ;;
            "diverged")
                    log-info "As we have rebased the current branch $CURRENT_BRANCH onto $TARGET_BRANCH, we need to push the changes to the remote branch."
                    read -p "Do you want to push (force-with-lease) the changes to $UPSTREAM? (y/n): " choice
                    if [[ "$choice" == "y" ]]; then
                        git push --force-with-lease || die 1 "Failed to push changes to $UPSTREAM."
                    else
                        $VERBOSE && log-warn "Skipping push operation."
                    fi
                ;;
            *)
                log-warn "Unknown upstream status: $status"
                ;;
        esac
    fi
fi

if [ "$CHANGES_STASHED" = true ]; then
    git stash pop || die 1 "Failed to apply stashed changes."
    $VERBOSE && log-info "Stashed changes applied."
fi